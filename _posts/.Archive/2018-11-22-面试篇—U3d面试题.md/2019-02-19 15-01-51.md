---
layout:     post
title:      面试篇
subtitle:   2019 U3d面试题整理
date:       2018-11-22
author:     Rone
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - Unity
    - Interview
---

# 前言
> 恰逢下周面试，目的是为了提供一个便捷的翻阅方案，故有此博客。
>
> 每一场面试都是一场修行，也是一个难得的与别人交流的机会。作为候选人，完全可以放下包袱，摆正自己的心态，抓住这个机会去和面试官学习，交流。这样的话哪怕最后没有被对方录取，但最起码自己因此而了解一个新的视角或者一个新的领域，使得自己不断精进。
> 期待每一个看到这些文章的待业人员，能在未来收获一份自己满意的工作。

## C#基础相关

#### 1、在类的构造函数前加上static会报什么错?为什么?
  构造函数格式为 public+类名，如果加上static会报错（静态构造函数不能有访问修饰符）原因：静态构造函数不允许访问修饰符，也不接受任何参数。
无论创建多少类型的对象，静态构造函数只执行一次。 静态构造函数执行先于任何实例级别的构造函数，显然也就无法使用this和base来调用构造函数。
举一个例子，假如每一个实例都可以看作是一个口袋，那么构造函数就相当于袋口，是否多个口袋都能使用同一个袋口呢？我觉得是不能！

#### 2、请简述值类型与引用类型的区别
值类型传递的是值本身，引用类型传递的是地址。举个例子值类型就是现金,要用直接用;引用类型是存折,要用还得先去银行取现。

#### 3、请简述GC(垃圾收集)产生的原因，并描述如何避免。
  用new创建一个对象时，当可分配的内存不足GC就会去回收未使用的对象，但是GC的操作是非常复杂的，会占用很多CPU时间，对于移动设备来说频繁的垃圾回收会严重影响性能。下面的建议可以避免GC频繁操作。
 
 - 减少用new创建对象的次数，在创建对象时会产生内存碎片，这样会造成碎片内存不法使用
 
 - 使用公用的对象（静态成员，常量），但是不能乱用，因为静态成员和常量的生命周期是整个应用程序。
 
 - 在拼接大量字符串时StringBuilder。在使用注意，创建StringBuilder对象时要设置StringBuilder的初始大小如：StringBuilder sbHtml = new StringBuilder (size);
 
 - 使用object pool(对象池)


#### 4、请描述interface和抽象类之间的不同
包含一个或者多个抽象方法的类必须被声明为抽象类，抽象类可以声明方法的存在而不去实现它，被声明为抽象的方法不能包含方法体。在抽象类的子类中，实现方法必须含有相同或者更低的访问级别。。
接口与抽象类的相同点：
 - 都不能被实例化。

 - 接口的实现类或抽象类的子类都只有实现了接口或者抽象类中的方法后才能被实例化。

 - 接口与抽象类的不同点：

 - 接口只有定义不能有方法的实现，而抽象类可以有定义和实现。

 - 一个类可以实现多个接口但是可以继承多个实现类。

 - 接口强调特定功能的实现，抽象类强调所属关系。

 - 接口中定义的成员变量默认为public static final，只能够有静态的不能被修改的数据成员，而且，必须赋初值，所有的成员方法都是public、abstract。抽象类可以有自己的数据成员变量，也可以有非抽象的成员方法，而且成员方法可以在子类中被重新定义，也可以被重新赋值。

#### 5.下列代码在运行中会发生什么问题？如何避免？
List<int> Is=new List<int>(new int[]{1,2,3,4,5});
foreach(int n in Is)
{
Debug.Log(n*n);
Is.Remove(n);
}
remove操作会抛出异常，避免的话使用for来避免
一种解决方案
List<int> Is=new List<int>(new int[]{1,2,3,4,5});
for(int i = 0;i<Is.Count; i++)
{
Debug.Log(n*n);
Is.Remove(n);
i--;
}
#### 6.请简述private，public，protected，internal的区别
 - private：私有成员，在类的内部才可以访问。
 - public：公共成员，完全公开，没有访问限制。
 - protected：保护成员，该类内部和继承中可以访问。
 - internal：当前程序集内可以访问。
#### 7.请简述private，public，protected，internal的区别
反射的定义：审查元数据并收集关於它的类型信息的能力,元数据(编辑后的基本数据单元)就是一大堆表，编译器会创建一个类定义表，一个字段定义表，一个方法定义表等,System.Reflection命名空间包含的几个类，允许你反射(解析)这些元数据的代码
反射的作用：动态的创建类型的实例,将类型邦定到现有对象，或从现有对象中获取类型。应用程序需要在运行时从某个特定的程序集中载入一个特定的类型，以便实现某个任务时可以用到反射 。反射主要应用於类库，这些类库需要知道一个类型的定义，以便提供更多的功能。
#### 8、请说出4种面向对象的设计原则，并分别简述它们的含义。
 - 单一职责原则 （The Single Responsiblity Principle，简称SRP）：一个类，最好只做一件事，只有一个引起它的变化.
 - 开放－封闭原则 （The Open－Close Principle，简称OCP）：对于扩展是开放的，对于更改是封闭的
 - Liskov 替换原则（The Liskov Substitution Principle,简称LSP）：子类必须能够替换其基类
 - 依赖倒置原则（The Dependency Inversion Pricinple，简称DIP）：依赖于抽象
 - 接口隔离原则 （The Interface Segregation Principle，简称ISP）：使用多个小的专门的接口，而不要使用一个大的总接口。
## Unity基础相关
#### 1.请简述四元数的作用以及四元数相对欧拉角的优点。
 四元数一般定义如下：q=w+xi+yj+zk其中 w,x,y,z是实数。同时，有: ii=-1    jj=-1    k*k=-1
 四元数也可以表示为： q=[w,v]
 有多种方式可表示旋转，如 axis/angle、欧拉角(Euler angles)、矩阵(matrix)、四元组等。 相对于其它方法，四元组有其本身的优点：

 - 四元数不会有欧拉角存在的 gimbal lock 问题[万向节死锁]

 - 四元数由4个数组成，旋转矩阵需要9个数

 - 两个四元数之间更容易插值

 - 四元数、矩阵在多次运算后会积攒误差，需要分别对其做规范化(normalize)和正交化 (orthogonalize)，对四元数规范化更容易

 - 与旋转矩阵类似，两个四元组相乘可表示两次旋转
#### 2.请简述.Net与Mono之间的关系。
NET是一套标准，.Net Framework和Mono都是它的实现，支持C#语言。Mono是.Net的一个工具，.Net只能在Windows平台下跑，Mono可以跨平台，可以运行于Linux，FreeBSD，Unix，OS X和Solaris

#### 3、<愤怒的小鸟>给予初速度以后,怎么让小鸟受到重力和空气阻力的影响而绘制抛物线轨迹,说出具体的计算方法.
  假设初速度的方向Vector3 v = new Vector3(x,y,z),重力为g，阻力为f，鸟儿的质量为1

	--- 
	//解决方案是针对水平面和垂直方向做两次偏移处理，附解决方案。    
	Vector3 v;  //初速度
    float g;    //重力
    float f;    //阻力
	// Update is called once per frame
	void Update () {
        //获取水平偏移向量
        Vector3 horizontalVec = new Vector3(v.x, 0, v.z);
        //处理垂直方向速度
        v -= Vector3.up * g * Time.deltaTime;
        //处理水平方向速度
        v -= horizontalVec.normalized * f * Time.deltaTime;

        transform.Translate(v); 
    }
	
	---
	
#### 4.请描述游戏动画有哪几种，以及其原理。
主要有关节动画、单一网格模型动画(关键帧动画)、骨骼动画。

 - 关节动画把角色分成若干独立部分，一个部分对应一个网格模型，部分的动画连接成一个整体的动画，角色比较灵活Quake2中使用了这种动画;

 - 单一网络模型动画由一个完整的网格模型构成，在动画序列的关键帧里记录各个顶点的原位置及其改变量，然后插值运算实现动画效果，角色动画较真实。

 - 骨骼动画，广泛应用的动画方式，集成了以上两个方式的优点，骨骼按角色特点组成一定的层次结构，由关节相连，可做相对运动，皮肤作为单一网格蒙在骨骼之外，决定角色的外观。皮肤网格每一个顶点都会受到骨骼的影响，从而实现完美的动画。

#### 5.alpha blend 工作原理
实际显示颜色 = 前景颜色*Alpha/255 + 背景颜色*(255-Alpha)/255

#### 6.写光照计算中的diffuse的计算公式
漫反射光(diffuse)计算公式为：Idiffuse = Dintensity*Dcolor*N.L ; (Dintensity表示漫反射强度，Dcolor表示漫反射光颜色，N为该点的法向量，L为光源向量)
其他，3D渲染中，物体表面的光照计算公式为：
I = 环境光(Iambient) + 漫反射光(Idiffuse) + 镜面高光(Ispecular);
其中，环境光(ambient)计算公式为：
Iambient= Aintensity* Acolor; (Aintensity表示环境光强度，Acolor表示环境光颜色)
漫反射光(diffuse)计算公式为：
Idiffuse = Dintensity*Dcolor*N.L ; (Dintensity表示漫反射强度，Dcolor表示漫反射光颜色，N为该点的法向量，L为光源向量)
镜面光照(specular)计算公式为：
Ispecular = Sintensity*Scolor*(R.V)n; (Sintensity表示镜面光照强度，Scolor表示镜面光颜色，R为光的反射向量，V为观察者向量)
综上所得：整个光照公式为：
I = Aintensity* Acolor+ Dintensity*Dcolor*N.L + Sintensity*Scolor*(R.V)n ;
将一些值合并，并使用白色作为光照颜色，则上述公式可简化为：
I = A + D*N.L + (R.V)n

#### 7.lod是什么，优缺点是什么
LOD技术即Levels of Detail的简称，意为多细节层次。LOD技术指根据物体模型的节点在显示环境中所处的位置和重要度，决定物体渲染的资源分配，降低非重要物体的面数和细节度，从而获得高效率的渲染运算。
优点：可根据距离动态地选择渲染不同细节的模型
缺点：加重美工的负担，要准备不同细节的同一模型，同样的会稍微增加游戏的容量。

#### 8.两种阴影判断的方法工作原理
阴影由两部分组成：本影与半影
本影：景物表面上那些没有被光源直接照射的区域（全黑的轮廓分明的区域）
半影：景物表面上那些被某些特定光源直接照射但并非被所有特定光源直接照射的区域（半明半暗区域）
求阴影区域的方法：做两次消隐过程
一次对每个光源进行消隐，求出对于光源而言不可见的区域L；
一次对视点的位置进行消隐，求出对于视点而言可见的面S；
shadow area= L ∩ S
阴影分为两种：自身阴影和投射阴影
自身阴影：因物体自身的遮挡而使光线照射不到它上面的某些可见面
工作原理：利用背面剔除的方法求出，即假设视点在点光源的位置。
投射阴影：因不透明物体遮挡光线使得场景中位于该物体后面的物体或区域受不到光照照射而形成的阴影
工作原理：从光源处向物体的所有可见面投射光线，将这些面投影到场景中得到投影面，再将这些投影面与场景中的其他平面求交得出阴影多边形，保存这些阴影多边形信息，然后再按视点位置对场景进行相应处理得到所要求的视图（利用空间换时间，每次只需依据视点位置进行一次阴影计算即可，省去了一次消隐过程）
若是动态光源此方法就无效了。

#### 9.Vertex Shader是什么？怎么计算？
顶点着色器是一段执行在GPU上的程序，用来取代fixed pipeline中的transformation和lighting，Vertex Shader主要操作顶点。
Vertex Shader对输入顶点完成了从local space到homogeneous space（齐次空间）的变换过程，homogeneous space即projection space的下一个space。在这其间共有world transformation, view transformation和projection transformation及lighting几个过程。

#### 10.MipMap是什么？作用？
在三维计算机图形的贴图渲染中有一个常用的技术被称为Mipmapping。为了加快渲染速度和减少图像锯齿，贴图被处理成由一系列被预先计算和优化过的图片组成的文件,这样的贴图被称为 MIP map 或者 mipmap

#### 11.u3d中碰撞器和触发器的区别？
碰撞器会有碰撞的效果，IsTrigger = false,可以调用OnCollisionEnter/Stay/Exit函数。    触发器没有碰撞效果，isTrigger = true,可以调用OnTriggerEnter/stay/exit函数

#### 12.物体发生碰撞的必要条件
先列出三个组合1.CharacterController 2.Collider + Rigidbody 3.Collider
发生碰撞的双方至少有一方满足1或者2，另一方满足三这种任意一点就可以。

#### 13.什么叫做链条关节
Hinge Joint ，他可以模拟两个物体间用一根链条连接在一起的情况，能保持两个物体在一个固定距离内部相互移动而不产生作用力，但是达到固定距离后就会产生拉力。


#### 14.CharacterController和Rigidbody的区别
CharacterController自带胶囊碰撞器，里面好像封装了一个刚体
Rigidbody就是刚体，使物体带有物理的特性

#### 15.物体发生碰撞时，有几个阶段，分别对应的函数
三个阶段，OnCollisionEnter/Stay/Exit函数

#### 16.u3d中，几种施加力的方式，描述出来。
rigidbody.AddForce/AddForceAtPosition，都在rigidbody系列函数

#### 17.物体自旋转使用的函数叫什么，物体绕某点旋转使用函数叫什么
物体自旋转使用transform.Rotate，物体绕某点旋转使用transform.RotateAround

#### 18.u3d提供了一个用于保存读取数据的类，（playerPrefs），请列出保存读取整形数据的函数
PlayerPrefs.SetInt(“CoinNum”,100)，需要值得注意的是，在多个打开的UnityEditor中,PlayerPrefs的值好像会受到影响。

#### 19.unity3d从唤醒到销毁有一段生命周期，请列出系统自己调用的几个重要方法。
Awake --->OnEnable  ---> Start ---> Update  --> FixedUpdate --> LateUpdate --->OnGUI -->Reset --> OnDisable -->OnDestory;

#### 20.物理更新一般在哪个系统函数里？
FixedUpdate，每固定帧绘制时执行一次，和update不同的是FixedUpdate是渲染帧执行，如果你的渲染效率低下的时候FixedUpdate调用次数就会跟着下降。FixedUpdate比较适用于物理引擎的计算，因为是跟每帧渲染有关。Update就比较适合做控制。

#### 21.移动相机动作在哪个函数里，为什么在这个函数里。
LateUpdate,在每帧执行完毕调用，他是在所有update结束后才掉，比较适合用于命令脚本的执行。官网上例子是摄像机的跟随，都是在所有update操作完才跟进摄像机，不然就有可能出现摄像机已经推进了，但是视角里还未有角色的空帧出现。

#### 22.当游戏中需要频繁创建一个物体对象时，我们需要怎么做来节省内存。
使用对象池，可根据需求来确定是倒计时重置还是主动重置。当然一般情况下，不存在那种只创建不处理的情况。

#### 23.一个场景放置多个camera并同时处于活动状态，会发生什么
实际看到的画面由多个camera的画面组成，由depth、Clear Flag、Culling Mask都会影响最终合成效果。

#### 24.为什么u3d会出现组件上数据丢失的情况
一般是组件上绑定的物体对象被删除了。

#### 25.u3d下如何安全的在不同工程迁移asset数据
方法1，可以把assets目录和Library目录一起迁移，
方法2，导出包，
方法3，用unity带的assets server功能

#### 26.用u3d实现2d游戏，有几种方式？
1.利用引擎自带的GUI
2.把摄像机设为Orthographic，用面片作为2d元素
3.利用第三方插件：NGUI、2dToolkit

#### 27、Unity3D中的协程（coroutine）和C#线程之间的区别是什么？
unity提供了StartCoroutine（协同程序）和LoadLevelAsync（异步加载关卡）后台加载场景的方法。 StartCoroutine为什么叫协同程序呢，所谓协同，就是当你在StartCoroutine的函数体里处理一段代码时，利用yield语句等待执行结果，这期间不影响主程序的继续执行，可以协同工作。而LoadLevelAsync则允许你在后台加载新资源和场景，所以再利用协同，你就可以前台用loading条或动画提示玩家游戏未卡死，同时后台协同处理加载的事宜asynchronous[e ɪˈ s ɪŋ kr ə n ə s] .synchronous同步。

#### 28、请简述向量的点乘，向量的叉乘以及向量归一化的意义。
向量的点乘  用来求向量之间的夹角或者用来判断向量是否在同一方向、以及在某一方向的投影。
判断如下：
a·b>0   方向基本相同，夹角在0°到90°之间
a·b=0   正交
a·b<0  方向基本相反，夹角在90°到180°之间
向量的叉乘 在Unity中的作用是用来求向量所在平面的法向量。
归一化的结果是获取目标方向上长度为1单位的向量

#### 29、请简述为什么dynamic font在unicode环境下优于static font
[请翻阅参考](http://www.ceeger.com/Components/class-Font.html)

#### 30、什么是渲染管道？
是指在显示器上为了显示出图像而经过的一系列必要操作。
渲染管道中的很多步骤，都要将几何物体从一个坐标系中变换到另一个坐标系中去。
主要步骤有：
本地坐标->视图坐标->背面裁剪->光照->裁剪->投影->视图变换->光栅化。

#### 31、如何优化内存？
有很多种方式，例如
 - 压缩自带类库
 
 - 将暂时不用的以后还需要使用的物体隐藏起来而不是直接Destroy掉
 
 - 释放AssetBundle占用的资源；AssetBundle资源包
 
 - 降低模型的片面数，降低模型的骨骼数量，降低贴图的大小

 - 使用光照贴图，使用多层次细节(LOD)，使用着色器(Shader)，使用预设(Prefab)

#### 32、请简述OnBecameVisible及OnBecameInvisible的发生时机，以及他们执行的意义？
当renderer(渲染器)在任何相机上都不可见时调用：OnBecameInvisible
当renderer(渲染器)在任何相机上可见时调用：OnBecameVisible

#### 33、Material和Physic Material区别？
PhysicMaterial 物理材质：物理材质描述，如何处理物体碰撞（摩擦，弹性）。
Material材质（材质类）为了获得一个对象使用的材质，可以使用 Renderer.materia属性：

#### 34、Material和Physic Material区别？
Shader（着色器）实际上就是一小段程序，它负责将输入的Mesh（网格）以指定的方式和输入的贴图或者颜色等组合作用，然后输出。绘图单元可以依据这个输出来将图像绘制到屏幕上。输入的贴图或者颜色等，加上对应的Shader，以及对Shader的特定的参数设置，将这些内容（Shader及输入参数）打包存储在一起，得到的就是一个Material（材质）
Shader大体上可以分为两类:表面着色器（Surface Shader） 、片段着色器（Fragment Shader）


